---
interface Props {
    width: number;
    height: number;    
};

const { width, height } = Astro.props;
---

<canvas id="conway" width={width} height={height}></canvas>

<script define:vars={{width, height}}>
    let bitGrid = new Uint8Array(Math.ceil(width * height / 8));
    let nextGrid = new Uint8Array(Math.ceil(width * height / 8));
    const canvas = document.getElementById("conway");
    const ctx = canvas.getContext("2d");
    const cellSize = 25;
    const rows = Math.floor(height / cellSize);
    const cols = Math.floor(width / cellSize);

    function getCell(grid, x, y) {
        const index = y * width + x;
        const byte = Math.floor(index / 8);
        const bit = index % 8;
        return (grid[byte] & (1 << bit)) !== 0;
    }
    
    function setCell(grid, x, y, state) {
        const index = y * width + x;
        const byte = Math.floor(index / 8);
        const bit = index % 8;
        if (state) {
            grid[byte] |= (1 << bit);
        } else {
            grid[byte] &= ~(1 << bit);
        }
    }

    function randomizeGrid() {
        for (let y = 0; y < rows; y++) {
            for (let x = 0; x < cols; x++) {
                setCell(bitGrid, x, y, Math.random() > 0.6 ? 1 : 0);
            }
        }
    }

    function initPattern() {
        setCell(bitGrid, 10, 10, 1);
        setCell(bitGrid, 10, 11, 1);
        setCell(bitGrid, 9, 11, 1);
        setCell(bitGrid, 10, 12, 1);
        setCell(bitGrid, 11, 12, 1);
    }

    function computeNextGen() {
        for (let y = 0; y < rows; y++) {
            for (let x = 0; x < cols; x++) {
                let liveNeighbors = 0;

                // Check all neighbors
                for (let dy = -1; dy <= 1; dy++) {
                    for (let dx = -1; dx <= 1; dx++) {
                        if (dx === 0 && dy === 0) continue;
                        const nx = x + dx;
                        const ny = y + dy;

                        if (nx >= 0 && ny >= 0 && nx < cols && ny < rows) {
                            liveNeighbors += getCell(bitGrid, nx, ny);
                        }
                    }
                }

                const isAlive = getCell(bitGrid, x, y);
                if (isAlive && (liveNeighbors === 2 || liveNeighbors ===3)) {
                    setCell(nextGrid, x, y, 1) // Stays alive
                } else if (!isAlive && liveNeighbors === 3) {
                    setCell(nextGrid, x, y, 1) // It's alive!
                } else {
                    setCell(nextGrid, x, y, 0); // Death ðŸ’€
                }
            }
        }

        // Swap the grids
        [bitGrid, nextGrid] = [nextGrid, bitGrid];
    }

    function renderGrid() {
        ctx.clearRect(0, 0, width, height);

        for (let y = 0; y < rows; y++) {
            for (let x = 0; x < cols; x++) {
                if (getCell(bitGrid, x, y)) {
                    ctx.fillStyle = "rgb(30, 30, 35)";
                    ctx.fillRect(x * cellSize, y * cellSize, cellSize, cellSize);
                }
            }
        }

        // Draw grid lines
        ctx.strokeStyle = 'rgb(15, 15, 15)'; // Light gray color for the grid
        ctx.lineWidth = 1;

        for (let x = 0; x <= cols; x++) {
            ctx.beginPath();
            ctx.moveTo(x * cellSize, 0);
            ctx.lineTo(x * cellSize, height);
            ctx.stroke();
        }

        for (let y = 0; y <= rows; y++) {
            ctx.beginPath();
            ctx.moveTo(0, y * cellSize);
            ctx.lineTo(width, y * cellSize);
            ctx.stroke();
        }
    }

    function loop() {
        computeNextGen();
        renderGrid();
        setTimeout(loop, 200)
    }

    initPattern();
    loop();

</script>